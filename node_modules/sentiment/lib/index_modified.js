/**
 * AFINN-based sentiment analysis for Node.js
 *
 * @package sentiment
 * @author Shubhi Yede <shubhi.yede@gmail.com>
 */

/**
 * Dependencies
 */
var extend = require('extend-object');
var afinn = require('../build/AFINN.json');

/**
 * Tokenizes an input string.
 *
 * @param {String} Input
 *
 * @return {Array}
 */
function tokenize (input) {
    //console.log(input);
    var result = input
            .replace(/[^a-zA-Z- ]+/g, '')
            .replace('/ {2,}/',' ')
            .toLowerCase()
            .split(' ');
     return result;
}
function log10(val) {
  return Math.log(val) / Math.LN10;
}

function TF(freq){
  var tf=1+log10(1+log10(freq));
  return tf;
}

function IDF(d,dt){
  var idf=log10((1+d)/dt);
  return idf;
}

function cosineDistance(v1, v2){
    var numerator=0,sqrt_v1=0,sqrt_v2=0;
   	for(var i=0; i<v1.length; i++){
   		numerator+=v1[i]*v2[i];
   		sqrt_v1+=Math.pow(v1[i],2);
   		sqrt_v2+=Math.pow(v2[i],2);
   	}
   	sqrt_v1 = Math.sqrt(sqrt_v1);
   	sqrt_v2 = Math.sqrt(sqrt_v2);
   	var denominator = sqrt_v1 * sqrt_v2;
   	if(denominator > 0){
   	  var cosineDist = numerator / denominator;
   	  return cosineDist;
   	}
   	else
   	  return 0;
   	
}
function cosineSimilarity(v1,v2){
    var angle=Math.acos(cosineDistance(v1, v2));
    angle=Math.round(angle * 100) / 100;
    return angle; 
}

function mult(X, Y){
  //X (r1 x c1)  Y(r2 x c2)
  //c1 == r2
  console.log("X rows = "+ X.length + " X columns = "+ X[0].length+ " Y rows = " + Y.length + " Y columns = " + Y[0].length);
	if(X[0].length != Y.length){ 
	  console.log('Invalid dimension!');
	  return null;
	}
	// dimensions
	var m = X.length, n = Y[0].length, d = Y.length;
	// multiplication
	var Z = new Array(X.length);
	for(var i = 0; i < X.length; ++i){
		Z[i] = new Array(Y[0].length);
		for(var j = 0; j < Y[0].length; ++j){
			Z[i][j] = X[i].map(function(x, k){
				return x * Y[k][j];
			}).reduce(function(a, b){ return a + b; }, 0);
		}
	}
	return Z;
}

/**
 * Performs sentiment analysis on the provided input "phrase".
 *
 * @param {String} Input phrase
 * @param {Object} Optional sentiment additions to AFINN (hash k/v pairs)
 *
 * @return {Object}
 */
module.exports = function (phrase, inject, callback) {
    // Parse arguments
    if (typeof phrase === 'undefined') phrase = '';
    if (typeof inject === 'undefined') inject = null;
    if (typeof inject === 'function') callback = inject;
    if (typeof callback === 'undefined') callback = null;

    // Merge
    if (inject !== null) {
        afinn = extend(afinn, inject);
    }
    
    var totalTweets=phrase.length;

    // Storage objects
    /*
    column=words
    rows=tweets_word_freq
        stock, equity, asset, liability, revenue, EBITDA, profit, loss, cash, up, down
    tw1
    tw2
    tw3
    tw4
    tw5
    */
    var counter = [0,0,0,0,0,0,0,0,0,0,0];
    var vsm = [];
    //stock equity asset liability revenue EBITDA profit loss cash up down
    var relevant_words = ["stock", "equity", "asset", "liability", "revenue", "EBITDA", "profit", "loss", "cash", "up","down"];
    var score=0;
    var new_row_vector = [];
    var i;
    for(i=0; i<phrase.length ; ++i){
      
      //Tokenization
      
      var tokens = tokenize(phrase[i]);
      var len = tokens.length;
      new_row_vector = [0,0,0,0,0,0,0,0,0,0,0];
      while (len--) { 
        var word = tokens[len];
        if (!afinn.hasOwnProperty(word)){
          continue;
        } 
        var weight = afinn[word];
        
        //to measure if tweet is positive or negative
        score += weight;
        
        //Vector Space Model
        //to find if tweet is relevant or irrelevant
        var index = relevant_words.indexOf(word);
        if(index > -1){
          new_row_vector[index]=weight;
          counter[index]+=1;
        }
      }
      vsm.push(new_row_vector);
    }
    
    //Display Vector Space Model
    console.log("VSM:");
    for(i=0; i<vsm.length; ++i){
      console.log(vsm[i]);
    }
    
    //TF-IDF
    var idf_array = [];
    var d=vsm.length;
    for(i=0; i<11; ++i){
      var dt=counter[i];
      idf_array.push(IDF(d,dt));
    }
    var TD_IDF_matrix = vsm;
    var tweetTF_IDF_Weight = [];
    var maxWeight = -1000;
    var minWeight = 1000;
    var maxWeightTweet = -1;
    var minWeightTweet = -1;
    console.log("TF-IDF");
    for(i=0; i<vsm.length; ++i){
      var weightSum=0;
      for(j=0; j<11; ++j){
        if(vsm[i][j] != 0){
          //tf-idf weight of relevant_word[j] in tweet[i] is given by:
          TD_IDF_matrix[i][j]=TF(vsm[i][j])*idf_array[j];
          TD_IDF_matrix[i][j]=Math.round(TD_IDF_matrix[i][j] * 100) / 100;
          if(Number.NaN ===TD_IDF_matrix[i][j]){
            TD_IDF_matrix[i][j]=0;
          }
          weightSum+=TD_IDF_matrix[i][j];
        }
        console.log(TD_IDF_matrix[i]);
      }
      tweetTF_IDF_Weight.push(weightSum);
      if(tweetTF_IDF_Weight[i] < minWeight){
        minWeightTweet=i;
        minWeight=tweetTF_IDF_Weight[i];
      }
      if(tweetTF_IDF_Weight[i] > maxWeight){
        maxWeightTweet=i;
        maxWeight=tweetTF_IDF_Weight[i];
      }
    }
    console.log("maxWeightTweet="+maxWeightTweet+ " and its weight="+maxWeight);
    console.log("minWeightTweet="+minWeightTweet+ " and its weight="+minWeight);
    
    //Cosine similarity
    console.log("Cosine similarity:");
    /*
    var cosineAngle_matrix = [];
    
    console.log("totalTweets="+totalTweets);
    for(i=0; i<totalTweets-1; ++i){
      var v1 = vsm[i];
      for(j=i+1; j<totalTweets ; ++j){
        var v2 = vsm[j];
        cosineAngle_matrix.push([i,j,cosineSimilarity(v1,v2)]);
      }
    }
    //Display Cosine Similarity
    for(var i=0; i<cosineAngle_matrix.length; ++i){
      console.log(cosineAngle_matrix[i]);
    }
    */
    var vector1 = vsm[maxWeightTweet];
    var vector2 = vsm[minWeightTweet];
    var maxAngle = cosineSimilarity(vector1,vector2);
    console.log("Opposite tweets deflect by "+maxAngle);
    
    //LSA using SVD
    var svd = require('node-svd').svd;
    console.log('-----calculating svd-----');
    var res = svd(vsm, 0, { U: true, V: true, debug: 2});
    console.log('---');
    var U = res.U;
    var S = res.S;
    var V = res.V;
    
    
    console.log('U = %s', JSON.stringify(U));
    console.log('S = %s', JSON.stringify(S));
    console.log('V = %s', JSON.stringify(V));
    
    
    var rows, columns;
    rows=vsm.length;
    columns = vsm[0].length;
    console.log('vsm is a '+rows+' by '+columns+' matrix');
    rows=U.length;
    columns = U[0].length;
    console.log('U is a '+rows+' by '+columns+' matrix');
    //console.log('U = %s', JSON.stringify(U));
    
    //Displaying U
    for (i=0; i<rows; ++i){
      for (j=0; j<columns; ++j){
        //U[i][j]=Math.round(U[i][j] * 100) / 100;
        process.stdout.write(U[i][j]+', ');
      }
      process.stdout.write('\n');
    }
    
    
    var newS = [];
    console.log("Creating New S ");
    for (i=0; i<S.length; ++i){
      var tuple = [];
      for(j=0; j<S.length; ++j){
        tuple.push(0);
      }
      var temp = tuple;
      temp[i] = S[i];
      newS.push(temp);
    }
    rows=newS.length;
    columns = newS[0].length;
    console.log('!!!!!!!     newS is a '+rows+' by '+columns+' matrix');

    //Displaying newS
    for (i=0; i<rows; ++i){
      for (j=0; j<columns; ++j){
        process.stdout.write(newS[i][j]+', ');
      }
      process.stdout.write('\n');
    }
    
    rows=V.length;
    columns = V[0].length;
    console.log('V is a '+rows+' by '+columns+' matrix');
    
    //Displaying V
    for (i=0; i<rows; ++i){
      for (j=0; j<columns; ++j){
        //V[i][j]=Math.round(V[i][j] * 100) / 100;
        process.stdout.write(V[i][j]+', ');
      }
      process.stdout.write('\n');
    }
    
     //features in decending order in S ...
    var feature1 = S[0];  //strongest
    var feature2 = S[1];  //next strongest
    
    var VS = mult(V,newS);
    rows=VS.length;
    columns = VS[0].length;
    console.log('VS is a '+rows+' by '+columns+' matrix that describes relation between relevant words and features');
    //Displaying VS
    for (i=0; i<rows; ++i){
      for (j=0; j<columns; ++j){
        process.stdout.write(VS[i][j]+', ');
      }
      process.stdout.write('\n');
    }
    
    //Determining which relevant word is part of which of the two stongest features.
    var feature1Words = [];
    var feature2Words = [];
    var feature1Sentiment=0;
    var feature2Sentiment=0;
  
    for (i=0; i<rows; ++i){
      if(VS[i][0] > VS[i][1]){
        feature1Words.push(relevant_words[i]);
        if(afinn.hasOwnProperty(relevant_words[i])){
          var weight = afinn[relevant_words[i]];
          feature1Sentiment+=weight;
        }
      }
      else if(VS[i][0] < VS[i][1]){
        feature2Words.push(relevant_words[i]);
        if(afinn.hasOwnProperty(relevant_words[i])){
          var weight = afinn[relevant_words[i]];
          feature2Sentiment+=weight;
        }
      }
    }

    console.log("Feature1 words = "+feature1Words);
    console.log("Feature2 words = "+feature2Words);
    var US = mult(U,newS);
    rows=US.length;
    columns = US[0].length;
    console.log('US is a '+rows+' by '+columns+' matrix that describes relation between tweets and features');
    var tweetCoordinates = [];
    for (i=0; i<rows; ++i){
      for (j=0; j<columns; ++j){
        process.stdout.write(US[i][j]+', ');
      }
      //                      f1:x-axis,f2:y-axis
      tweetCoordinates.push([US[i][0],US[i][1]]);
      process.stdout.write('\n');
    }
    
    rows=tweetCoordinates.length;
    columns = tweetCoordinates[0].length;
    console.log('tweetCoordinates is a '+rows+' by '+columns+' matrix');
    for (i=0; i<rows; ++i){
      for (j=0; j<columns; ++j){
        process.stdout.write(tweetCoordinates[i][j]+', ');
      }
      process.stdout.write('\n');
    }
    
    
    //k-means clustering
    var clusterfck = require("clusterfck");
    var kmeans = new clusterfck.Kmeans();
    // Calculate clusters.
    var clusters = kmeans.cluster(tweetCoordinates, 2);
    
    console.log('clusters matrix');
    
    for (i=0; i<clusters.length; ++i){
      console.log("cluster "+i+1);
      for (j=0; j<clusters[i].length; ++j){
        process.stdout.write(clusters[i][j]+'   ;   ');
      }
      process.stdout.write('\n');
    }
    
    console.log("CLUSTERING RESULT");
    console.log("Cluster 1 for words: ["+feature1Words+"] is of density="+clusters[0].length+" and sentimentScore="+feature1Sentiment);
    console.log("Cluster 2 for words: ["+feature2Words+"] is of density="+clusters[1].length+" and sentimentScore="+feature2Sentiment);
    
    var result = {
        score:          score,
        vsm:            vsm,
        feature1Words:  feature1Words,
        feature2Words:  feature2Words,
        feature1Sentiment:  feature1Sentiment,
        feature2Sentiment:  feature2Sentiment,
        VS:             VS,
        US:             US,
        clusters:       clusters
    };

    if (callback === null) return result;
    process.nextTick(function () {
        callback(null, result);
    });
};
